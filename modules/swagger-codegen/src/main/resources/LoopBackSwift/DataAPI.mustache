//
// Generated by swagger-codegen, do not edit!
// https://github.com/ConnectCorp/swagger-codegen
//
//  Copyright Â© 2016 Connect. All rights reserved.
//

import Foundation
import Alamofire
import RxSwift

public class DataAPI {
    {{#apis}}public let {{apiVarName}}:{{apiClassName}}{{#hasMore}}
    {{/hasMore}}{{/apis}}

    public init(manager:Manager, baseURL:Observable<NSURL>) {
        {{#apis}}{{apiVarName}} = {{apiClassName}}(manager: manager, baseURL: baseURL){{#hasMore}}
        {{/hasMore}}{{/apis}}
    }

    public func create<ModelType>(data:ModelType) throws -> Observable<ModelType> {
        {{#apis}}if data is {{modelClassName}} {
            return try {{apiVarName}}.create(data as! {{modelClassName}}).flatMap { return Observable.just($0 as! ModelType) }
        }{{#hasMore}}

        {{/hasMore}}{{/apis}}

        return Observable.create {
            $0.onError(UnsupportedModelType())

            return NopDisposable.instance
        }
    }

    public func update<ModelType>(data:ModelType) throws -> Observable<ModelType> {
        {{#apis}}if data is {{modelClassName}} {
            return try {{apiVarName}}.upsert(data as! {{modelClassName}}).flatMap { return Observable.just($0 as! ModelType) }
        }{{#hasMore}}

        {{/hasMore}}{{/apis}}

        return Observable.create {
            $0.onError(UnsupportedModelType())

            return NopDisposable.instance
        }
    }

    public func findById<ModelType>(type:ModelType.Type, id:Int64, filter:String) throws -> Observable<ModelType> {
        {{#apis}}if type.self == {{modelClassName}}.self {
            return try {{apiVarName}}.findById(id, filter: filter).flatMap { return Observable.just($0 as! ModelType) }
        }{{#hasMore}}

        {{/hasMore}}{{/apis}}

        return Observable.create {
            $0.onError(UnsupportedModelType())

            return NopDisposable.instance
        }
    }

    public func findOne<ModelType>(type:ModelType.Type, filter:String) throws -> Observable<ModelType> {
        {{#apis}}if type.self == {{modelClassName}}.self {
            return try {{apiVarName}}.findOne(filter).flatMap { return Observable.just($0 as! ModelType) }
        }{{#hasMore}}

        {{/hasMore}}{{/apis}}

        return Observable.create {
            $0.onError(UnsupportedModelType())

            return NopDisposable.instance
        }
    }

    public func find<ModelType>(type:ModelType.Type, filter:String) throws -> Observable<[ModelType]> {
        {{#apis}}if type.self == {{modelClassName}}.self {
            return try {{apiVarName}}.find(filter).flatMap { return Observable.just($0.map({ return $0 as! ModelType })) }
        }{{#hasMore}}

        {{/hasMore}}{{/apis}}

        return Observable.create {
            $0.onError(UnsupportedModelType())

            return NopDisposable.instance
        }
    }

    public func count<ModelType, CountType>(type:ModelType.Type, _where:String) throws -> Observable<CountType> {
        {{#apis}}if type.self == {{modelClassName}}.self {
            return try {{apiVarName}}.count(_where).flatMap { return Observable.just($0 as! CountType) }
        }{{#hasMore}}

        {{/hasMore}}{{/apis}}

        return Observable.create {
            $0.onError(UnsupportedModelType())

            return NopDisposable.instance
        }
    }

    public func deleteById<ModelType, DeleteType>(type:ModelType.Type, id:Int64) throws -> Observable<DeleteType> {
        {{#apis}}if type.self == {{modelClassName}}.self {
            return try {{apiVarName}}.deleteById(id).flatMap { return Observable.just($0 as! DeleteType) }
        }{{#hasMore}}

        {{/hasMore}}{{/apis}}

        return Observable.create {
            $0.onError(UnsupportedModelType())

            return NopDisposable.instance
        }
    }
}