import Alamofire
import ObjectMapper
import RealmSwift
import RxSwift
import LoopBackQuery

public class RealmSynced<APIType : API where APIType.ModelType : Object, APIType.ModelType : Mappable> {

    let api:APIType

    let realmManager:RealmManager

    let connectivityManager:ConnectivityManager

    public init(api:APIType, realmManager:RealmManager, connectivityManager:ConnectivityManager) {
        self.api = api
        self.realmManager = realmManager
        self.connectivityManager = connectivityManager
    }

    public func create(data:APIType.ModelType) throws -> Observable<APIType.ModelType> {
        return try api.create(data).doOnNext { [weak self] _ in
            if let repo = self {
                repo.realmManager.save(data, update: true)
            }
        }
    }

    public func update(data:APIType.ModelType) throws -> Observable<APIType.ModelType> {
        return try api.upsert(data).doOnNext { [weak self] _ in
            if let repo = self {
                repo.realmManager.save(data, update: true)
            }
        }
    }

    public func findById(id:String) throws -> Observable<APIType.ModelType> {
        if connectivityManager.isConnected {
            return try api.findById(id, filter: "{}")
        }

        if let data = realmManager.findById(APIType.ModelType.self, id: id) {
            return Observable.just(data)
        } else {
            return Observable.create {
                $0.onError(RealmError(message: "No data with id \(id)"))

                return NopDisposable.instance
            }
        }
    }

    public func findOne(query:Query) throws -> Observable<APIType.ModelType> {
        if connectivityManager.isConnected {
            return try api.findOne(query.toLoopBackString())
        }

        return Observable.create { [weak self] observer in
            if let repo = self {
                if let data = repo.realmManager.findOne(APIType.ModelType.self, predicate: query.toNSPredicate()) {
                    observer.onNext(data)
                } else {
                    observer.onError(RealmError(message: "No data matches the specified query."))
                }
            }

            return NopDisposable.instance
        }
    }

    public func find(query:Query) throws -> Observable<[APIType.ModelType]> {
        if connectivityManager.isConnected {
            return try api.find(query.toLoopBackString())
        }

        return Observable.create { [weak self] observer in
            if let repo = self {
                if let data = repo.realmManager.find(APIType.ModelType.self, predicate: query.toNSPredicate()) {
                    observer.onNext(data)
                } else {
                    observer.onError(RealmError(message: "No data matches the specified query."))
                }
            }

            return NopDisposable.instance
        }
    }

    public func deleteById(id:String) throws -> Observable<APIType.ModelType> {
        return Observable.create { [weak self] observer in
            do {
                if let repo = self {
                    _ = try repo.findById(id).subscribeNext { data in
                        do {
                            if repo.connectivityManager.isConnected {
                                let response:Observable = try repo.api.deleteById(id)
                                _ = response.subscribeNext { _ in
                                    repo.realmManager.delete(data)
                                    observer.onNext(data)
                                }
                            }
                        } catch {
                            observer.onError(error)
                        }
                    }
                }
            } catch {
                observer.onError(error)
            }

            return NopDisposable.instance
        }
    }
}