import Alamofire
import RxSwift
import LoopBackQuery

{{#operations}}public class {{repositoryClassName}} {
    let realmManager:RealmManager

    let connectivityManager:ConnectivityManager

    public let api:{{classname}}

    public init(alamofireManager:Manager, realmManager:RealmManager, connectivityManager:ConnectivityManager) {
        self.api = {{classname}}(manager: alamofireManager)
        self.realmManager = realmManager
        self.connectivityManager = connectivityManager
    }

    public func create(data:{{baseName}}) throws -> Observable<{{baseName}}> {
        return try api.create(data).doOnNext { [weak self] _ in
            if let repo = self {
                repo.realmManager.save(data, update: true)
            }
        }
    }

    public func update(data:{{baseName}}) throws -> Observable<{{baseName}}> {
        return try api.upsert(data).doOnNext { [weak self] _ in
            if let repo = self {
                repo.realmManager.save(data, update: true)
            }
        }
    }

    public func findById(id:String) throws -> Observable<{{baseName}}> {
        if connectivityManager.isConnected {
            return try api.findById(id, filter: "{}")
        }

        if let data = realmManager.findById({{baseName}}.self, id: id) {
            return Observable.just(data)
        } else {
            return Observable.create {
                $0.onError(RepositoryError(message: "No {{baseName}} with id \(id)"))

                return NopDisposable.instance
            }
        }
    }

    public func findOne(query:Query) throws -> Observable<{{baseName}}> {
        if connectivityManager.isConnected {
            return try api.findOne(query.toLoopBackString())
        }

        return Observable.create { [weak self] observer in
            if let repo = self {
                if let data = repo.realmManager.findOne({{baseName}}.self, predicate: query.toNSPredicate()) {
                    observer.onNext(data)
                } else {
                    observer.onError(RepositoryError(message: "No {{baseName}} matches the specified query."))
                }
            }

            return NopDisposable.instance
        }
    }

    public func find(query:Query) throws -> Observable<[{{baseName}}]> {
        if connectivityManager.isConnected {
            return try api.find(query.toLoopBackString())
        }

        return Observable.create { [weak self] observer in
            if let repo = self {
                if let data = repo.realmManager.find({{baseName}}.self, predicate: query.toNSPredicate()) {
                    observer.onNext(data)
                } else {
                    observer.onError(RepositoryError(message: "No {{baseName}} matches the specified query."))
                }
            }

            return NopDisposable.instance
        }
    }

    public func deleteById(id:String) throws -> Observable<{{baseName}}> {
        return Observable.create { [weak self] observer in
            do {
                if let repo = self {
                    let _ = try repo.findById(id).subscribeNext { data in
                        do {
                            if repo.connectivityManager.isConnected {
                                let _ = try repo.api.deleteById(id).subscribeNext { _ in
                                    repo.realmManager.delete(data)
                                    observer.onNext(data)
                                }
                            }
                        } catch {
                            observer.onError(error)
                        }
                    }
                }
            } catch {
                observer.onError(error)
            }

            return NopDisposable.instance
        }
    }
}{{/operations}}