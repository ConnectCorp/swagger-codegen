import Foundation
import Alamofire
import RxSwift
import RxAlamofire
import ObjectMapper
import AlamofireObjectMapper

extension Request {

    public func mapString() -> Observable<String> {
        return Observable.create { observer in
            self.responseString { [weak self] response in
                if let value = response.result.value {
                    observer.onNext(value)
                } else if let _ = response.result.error {
                    if let request = self {
                        request.onErrorResponse(response, observer: observer)
                    }
                }
            }

            return NopDisposable.instance
        }
    }

    public func mapObject<T : Mappable>(keyPath:String? = nil, toObject object:T? = nil) -> Observable<T> {
        return Observable.create { observer in
            self.responseObject(keyPath:keyPath, mapToObject: object) { [weak self] (response:Response<T, NSError>) in
                if let value = response.result.value {
                    observer.onNext(value)
                } else if let _ = response.result.error {
                    if let request = self {
                        request.onErrorResponse(response, observer: observer)
                    }
                }
            }

            return NopDisposable.instance
        }
    }

    func mapArray<T : Mappable>(keyPath:String? = nil) -> Observable<[T]> {
        return Observable.create { observer in
            self.responseArray(keyPath: keyPath) { [weak self] (response:Response<[T], NSError>) in
                if let value = response.result.value {
                    observer.onNext(value)
                } else if let _ = response.result.error {
                    if let request = self {
                        request.onErrorResponse(response, observer: observer)
                    }
                }
            }

            return NopDisposable.instance
        }
    }

    private func onErrorResponse<T>(response:Response<T, NSError>, observer:AnyObserver<T>) {
        guard let e = response.result.error else { return }

        if let error = response.response {
            if let data = response.data {
                observer.onError(APIError(request: self, statusCode: error.statusCode,
                    errorResponse: String(data: data, encoding: NSUTF8StringEncoding)))
            } else {
                observer.onError(APIError(request: self, statusCode: error.statusCode))
            }
        } else {
            observer.onError(e)
        }
    }
}

extension ObservableType where E == Request {
    // TODO: Specify a serialization queue?

    public func mapString() -> Observable<(String, Request)> {
        return self.flatMap { (r:Request) -> Observable<(String, Request)> in
            return r.mapString().map { (s:String) -> (String, Request) in
                return (s, r)
            }
        }
    }

    public func mapObject<T:Mappable>(keyPath:String? = nil, toObject object:T? = nil) -> Observable<(T, Request)> {
        return self.flatMap { (r:Request) -> Observable<(T, Request)> in
            return r.mapObject(keyPath, toObject: object).map { (object:T) -> (T, Request) in
                return (object, r)
            }
        }
    }

    public func mapArray<T:Mappable>(keyPath:String? = nil) -> Observable<([T], Request)> {
        return self.flatMap { (r:Request) -> Observable<([T], Request)> in
            return r.mapArray(keyPath).map { (array:[T]) -> ([T], Request) in
                return (array, r)
            }
        }
    }
}
